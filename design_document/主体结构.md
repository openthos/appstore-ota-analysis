
# 主体结构
- 以一个Activity为主题，其余通过Fragment的互相切换来实现

### 主要实现点

- 四个按钮的切换显示

  在这里，这四个用来切换页面的按钮主要是使用了Button，而没有用RadioButton，因为使用RadioButton的时候不能重复点击
  - 布局代码如下：
  
        <LinearLayout
            android:layout_width="0dp"
            android:layout_height="match_parent"
            android:layout_weight="2"
            android:gravity="center"
            android:layout_gravity="center">

            <Button
                android:id="@+id/rb_home"
                android:layout_width="wrap_content"
                android:layout_height="match_parent"
                style="@style/Main_Button"
                android:text="@string/home"
                />
            <Button
                android:id="@+id/rb_software"
                android:layout_width="wrap_content"
                android:layout_height="match_parent"
                style="@style/Main_Button"
                android:layout_marginLeft="20dp"
                android:text="@string/software"
                />
            <Button
                android:id="@+id/rb_game"
                android:layout_width="wrap_content"
                android:layout_height="match_parent"
                style="@style/Main_Button"
                android:layout_marginLeft="20dp"
                android:text="@string/game"
                />
            <Button
                android:id="@+id/rb_manager"
                android:layout_width="wrap_content"
                android:layout_height="match_parent"
                style="@style/Main_Button"
                android:layout_marginLeft="20dp"
                android:text="@string/manager"
                />
        </LinearLayout>
        
  - 每个小Button前面的图片设置是通过加载drawable对象来实现
  
        int[] drawables = new int[] {
                R.drawable.select_home_drawable,
                R.drawable.select_software_drawable,
                R.drawable.select_game_drawable,
                R.drawable.select_manager_drawable
        };
        int[] rids = new int[] {
                R.id.rb_home,
                R.id.rb_software,
                R.id.rb_game,
                R.id.rb_manager
        };
        Resources res = getResources();
        for (int i = 0; i < rids.length; i++) {
            Button rb = (Button) findViewById(rids[i]);
            rb.setOnClickListener(this);
            Drawable drawable = res.getDrawable(drawables[i]);
            drawable.setBounds(0, 0, Constants.DRAWABLE_SIZE, Constants.DRAWABLE_SIZE);
            rb.setCompoundDrawablePadding(Constants.DRAWABLE_PADDING);
            rb.setCompoundDrawables(drawable, null, null, null);
        }
        
  - 每个Button的点击的颜色切换以及页面跳转。previousButton是记录的上一次的按钮，currentButton是当前的按钮，以此来进行选中背景的选择。点击点击点击每个条目的时候通过Handler来发消息序列，进而进行界面刷新。
  
        class HomeItemClick implements View.OnClickListener {
            @Override
            public void onClick(View view) {
                currentButton = (Button) view;
                if (currentButton != previousButton) {
                    currentButton.setTextColor(getResources().getColor(R.color.blue));
                    if (previousButton != null) {
                        previousButton.setTextColor(getResources().getColor(R.color.gray));
                    }
                    previousButton = currentButton;
                    switch (view.getId()) {
                        case R.id.rb_home:
                            sendMessage(Constants.HOME_FRAGMENT, null);
                            break;
                        case R.id.rb_software:
                            sendMessage(Constants.SOFTWARE_FRAGMENT, null);
                            break;
                        case R.id.rb_game:
                            sendMessage(Constants.GAME_FRAGMENT, null);
                            break;
                        case R.id.rb_manager:
                            sendMessage(Constants.MANAGER_FRAGMENT, null);
                            break;
                    }
                }
            }
        }
        
        public static void sendMessage(int what, String obj) {
            mHandler.sendMessage(mHandler.obtainMessage(what, obj));
        }
- Handler的各种传值进行数据刷新

  - 这是整个应用页面跳转的核心，下面来看一下它的具体逻辑
        
        //初始化Handler
        private void initHandler() {
            mHandler = new Handler() {
                @Override
                public void handleMessage(Message msg) {
                    super.handleMessage(msg);
                    FragmentTransaction transaction = mManager.beginTransaction();
                    BaseFragment fragment = null;
                    switch (msg.what) {
                        case Constants.HOME_FRAGMENT:
                            fragment = mFragments.get(Constants.HOME_FRAGMENT);
                            if (fragment == null) {
                                fragment = new HomeFragment();
                                mFragments.put(Constants.HOME_FRAGMENT, fragment);
                            }
                            addFragment(transaction, fragment, msg.what);
                            break;
                        case Constants.SOFTWARE_FRAGMENT:
                            fragment = mFragments.get(Constants.SOFTWARE_FRAGMENT);
                            if (fragment == null) {
                                fragment = new SoftwareFragment();
                                mFragments.put(Constants.SOFTWARE_FRAGMENT, fragment);
                            }
                            addFragment(transaction, fragment, msg.what);
                            break;
                        case Constants.GAME_FRAGMENT:
                            fragment = mFragments.get(Constants.GAME_FRAGMENT);
                            if (fragment == null) {
                                fragment = new GameFragment();
                                mFragments.put(Constants.GAME_FRAGMENT, fragment);
                            }
                            addFragment(transaction, fragment, msg.what);
                            break;
                        case Constants.MANAGER_FRAGMENT:
                            fragment = mFragments.get(Constants.MANAGER_FRAGMENT);
                            if (fragment == null) {
                                fragment = new ManagerFragment();
                                mFragments.put(Constants.MANAGER_FRAGMENT, fragment);
                            }
                            addFragment(transaction, fragment, msg.what);
                            break;
                        case Constants.DETAIL_FRAGMENT:
                            fragment = mFragments.get(Constants.DETAIL_FRAGMENT);
                            if (fragment == null) {
                                fragment = new DetailFragment();
                                mFragments.put(Constants.DETAIL_FRAGMENT, fragment);
                            }
                            addFragment(transaction, fragment, msg.what);
                            if (getData(msg) != null) {
                                ((DetailFragment) fragment).setDatas((String) getData(msg));
                            }
                            break;
                        case Constants.MORE_FRAGMENT:
                            fragment = mFragments.get(Constants.MORE_FRAGMENT);
                            if (fragment == null) {
                                fragment = new MoreFragment();
                                mFragments.put(Constants.MORE_FRAGMENT, fragment);
                            }
                            addFragment(transaction, fragment, msg.what);
    
                            if (getData(msg) != null) {
                                ((MoreFragment) fragment).setData((AppLayoutInfo) getData(msg));
                            }
                            break;
                        case Constants.COMMENT_FRAGMENT:
                            fragment = mFragments.get(Constants.COMMENT_FRAGMENT);
                            if (fragment == null) {
                                fragment = new CommentFragment();
                                mFragments.put(Constants.COMMENT_FRAGMENT, fragment);
                            }
                            addFragment(transaction, fragment, msg.what);
    
                            ((CommentFragment) fragment).setDatas(Constants.getComment());
                            ((CommentFragment) fragment).setAll(true);
                            break;
                        case Constants.SEARCH_FRAGMENT:
                            fragment = mFragments.get(Constants.SEARCH_FRAGMENT);
                            if (fragment == null) {
                                fragment = new SearchFragment();
                                mFragments.put(Constants.SEARCH_FRAGMENT, fragment);
                            }
                            addFragment(transaction, fragment, msg.what);
                            if (getData(msg) != null) {
                                ((SearchFragment) fragment).setDatas((String) getData(msg));
                            }
                            break;
                        case Constants.TOAST:
                            Tools.toast(MainActivity.this, (String) msg.obj);
                            break;
                        case Constants.REFRESH:
                            Fragment currentFragment = getCurrentFragment();
                            if (currentFragment != null) {
                                BaseFragment baseFragment = (BaseFragment) currentFragment;
                                baseFragment.refresh();
                            }
                            break;
                        case Constants.UPDATE:
                            saveAllData();
                            break;
                    }
                    if (msg.what != Constants.TOAST && msg.what != Constants.REFRESH
                            && msg.what != Constants.UPDATE) {
                        transaction.commit();
                        mManager.executePendingTransactions();
                        fragment.refresh();
                    }
                }
            };
        }
    
        //将要要显示的fragment加入事物管理器，并加上tag（what）
        private void addFragment(FragmentTransaction transaction, Fragment fragment, int what) {
            Fragment currentFragment = getCurrentFragment();
            if (!fragment.isAdded()) {
                transaction.add(R.id.main_fragment_container, fragment, what + "");
            }
            if (currentFragment != null) {
                transaction.hide(currentFragment).show(fragment);
            } else {
                transaction.show(fragment);
            }
        }
  
        // 获得消息中携带的数据
        private Object getData(Message msg) {
            if (msg.obj != null) {
                return msg.obj;
            }
            Bundle data = msg.getData();
            if (data == null) {
                return null;
            }
            switch (msg.what) {
                case Constants.MORE_FRAGMENT:
                    return (AppLayoutInfo) data.getSerializable(Constants.APP_LAYOUT_INFO);
            }
            return null;
        }
  
- 下载数据的保存结构

     这里是记录下载数据的保存结构，通过这里的数据每次启动AppStore时候有一个数据加载
     
        @Override
        public void onCreate(SQLiteDatabase db) {
            String downloadsql = "CREATE TABLE IF NOT EXISTS " + DOWNLOAD_INFO + " ("
                    + "id INTEGER PRIMARY KEY  AUTOINCREMENT  NOT NULL , "
                    + "userID VARCHAR, "
                    + "taskID VARCHAR, "
                    + "url VARCHAR, "
                    + "filePath VARCHAR, "
                    + "fileName VARCHAR, "
                    + "fileSize VARCHAR, "
                    + "downLoadSize VARCHAR, "
                    + "isSuccess VARCHAR , "
                    + "packageName VARCHAR, "
                    + "iconUrl VARCHAR "
                    + ")";
            db.execSQL(downloadsql);
         }
